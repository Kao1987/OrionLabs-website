import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { blogAPI, type BlogPost as APIBlogPost, type BlogPostCreate, type BlogPostUpdate } from '@/services/api'

export interface BlogPost extends APIBlogPost {
  featured?: boolean
  publishedAt?: string | Date
  updatedAt?: string | Date
}

export interface BlogError {
  code: string
  message: string
  operation?: string
}

export const useBlogStore = defineStore('blog', () => {
  // 初始化時加入一些 mock 資料
  const posts = ref<BlogPost[]>([
    {
      id: '1',
      title: 'Vue 3 Composition API 深度解析',
      content: '在這篇文章中，我將深入探討 Vue 3 Composition API 的核心概念，包括 ref、reactive、computed 等響應式 API 的使用方式，以及如何運用這些 API 來構建更靈活、可維護的 Vue 應用程式。',
      excerpt: '深入了解 Vue 3 Composition API 的核心概念與實戰應用。',
      author: 'Orion',
      publishedAt: new Date('2024-01-15'),
      updatedAt: new Date('2024-01-15'),
      tags: ['Vue.js', '前端開發', 'JavaScript'],
      category: '前端技術',
      featured: true,
      status: 'published' as const,
      readTime: 8,
      views: 234,
      likes: 12,
      slug: 'vue-3-composition-api-deep-dive',
      featuredImage: '/api/placeholder/800/600'
    },
    {
      id: '2',
      title: 'TypeScript 進階技巧與最佳實踐',
      content: 'TypeScript 作為現代前端開發的重要工具，本文將分享一些進階使用技巧，包括泛型、裝飾器、模組系統等，幫助開發者寫出更安全、更可維護的代碼。',
      excerpt: '學習 TypeScript 進階特性，提升代碼品質與開發效率。',
      author: 'Orion',
      publishedAt: new Date('2024-02-01'),
      updatedAt: new Date('2024-02-01'),
      tags: ['TypeScript', '前端開發', '程式設計'],
      category: '前端技術',
      featured: true,
      status: 'published' as const,
      readTime: 12,
      views: 189,
      likes: 8,
      slug: 'typescript-advanced-techniques',
      featuredImage: '/api/placeholder/800/600'
    },
    {
      id: '3',
      title: 'Docker 容器化部署實戰',
      content: '容器化技術已成為現代軟體部署的標準，本文將介紹如何使用 Docker 進行應用程式的容器化，包括 Dockerfile 編寫、多階段建構、容器編排等實用技巧。',
      excerpt: '掌握 Docker 容器化技術，實現高效的應用程式部署。',
      author: 'Orion',
      publishedAt: new Date('2024-02-15'),
      updatedAt: new Date('2024-02-15'),
      tags: ['Docker', 'DevOps', '部署'],
      category: 'DevOps',
      featured: false,
      status: 'published' as const,
      readTime: 15,
      views: 156,
      likes: 6,
      slug: 'docker-containerization-guide',
      featuredImage: '/api/placeholder/800/600'
    },
    {
      id: '4',
      title: 'UI/UX 設計原則與實踐',
      content: '好的用戶體驗是產品成功的關鍵，本文將分享一些重要的 UI/UX 設計原則，包括色彩搭配、版面設計、互動設計等，並結合實際案例進行說明。',
      excerpt: '探討現代 UI/UX 設計的核心原則與實踐方法。',
      author: 'Orion',
      publishedAt: new Date('2024-03-01'),
      updatedAt: new Date('2024-03-01'),
      tags: ['UI/UX', '設計', '用戶體驗'],
      category: 'UI/UX',
      featured: true,
      status: 'published' as const,
      readTime: 10,
      views: 298,
      likes: 18,
      slug: 'ui-ux-design-principles',
      featuredImage: '/api/placeholder/800/600'
    },
    {
      id: '5',
      title: '個人品牌建立的心得分享',
      content: '在數位時代，建立個人品牌變得越來越重要。這篇文章分享我在建立個人品牌過程中的經驗與心得，包括內容創作、社群經營、網路形象塑造等方面的思考。',
      excerpt: '分享個人品牌建立的實戰經驗與深度思考。',
      author: 'Orion',
      publishedAt: new Date('2024-03-15'),
      updatedAt: new Date('2024-03-15'),
      tags: ['個人品牌', '職涯發展', '思考'],
      category: '個人分享',
      featured: false,
      status: 'published' as const,
      readTime: 7,
      views: 112,
      likes: 9,
      slug: 'personal-brand-building-experience',
      featuredImage: '/api/placeholder/800/600'
    }
  ])
  const currentPost = ref<BlogPost | null>(null)
  const isLoading = ref(false)
  const fetchLoading = ref(false)
  const createLoading = ref(false)
  const updateLoading = ref(false)
  const deleteLoading = ref(false)
  const error = ref<BlogError | null>(null)
  const searchQuery = ref('')
  const selectedTags = ref<string[]>([])
  const selectedCategory = ref('')
  const currentPage = ref(1)
  const postsPerPage = ref(10)

  const publishedPosts = computed(() =>
    (posts.value || []).filter(post => post.status === 'published')
  )

  const filteredPosts = computed(() => {
    let filtered = publishedPosts.value || []

    // 搜尋篩選
    if (searchQuery.value) {
      const query = searchQuery.value.toLowerCase()
      filtered = filtered.filter(post =>
        (post.title || '').toLowerCase().includes(query) ||
        (post.content || '').toLowerCase().includes(query) ||
        (post.excerpt || '').toLowerCase().includes(query) ||
        (post.tags || []).some(tag => tag.toLowerCase().includes(query)) ||
        (post.author || '').toLowerCase().includes(query)
      )
    }

    // 分類篩選
    if (selectedCategory.value) {
      filtered = filtered.filter(post => {
        const category = post.category
        return category === selectedCategory.value
      })
    }

    // 標籤篩選
    if (selectedTags.value.length > 0) {
      filtered = filtered.filter(post =>
        selectedTags.value.every(tag => (post.tags || []).includes(tag))
      )
    }

    return filtered.sort((a, b) =>
      new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
    )
  })

  const paginatedPosts = computed(() => {
    const start = (currentPage.value - 1) * postsPerPage.value
    const end = start + postsPerPage.value
    return filteredPosts.value.slice(start, end)
  })

  const totalPages = computed(() =>
    Math.ceil(filteredPosts.value.length / postsPerPage.value)
  )

  const categories = computed(() => {
    const cats = new Set<string>()
    ;(publishedPosts.value || []).forEach(post => {
      const category = post.category
      if (category) cats.add(category)
    })
    return Array.from(cats).sort()
  })

  const tagCounts = computed(() => {
    const counts = new Map<string, number>()
    ;(publishedPosts.value || []).forEach(post => {
      ;(post.tags || []).forEach(tag => {
        counts.set(tag, (counts.get(tag) || 0) + 1)
      })
    })
    return Array.from(counts.entries())
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count)
  })

  const featuredPosts = computed(() =>
    (publishedPosts.value || []).filter(post => post.featured).slice(0, 3)
  )

  const allTags = computed(() => {
    const tags = new Set<string>()
    ;(publishedPosts.value || []).forEach(post => {
      ;(post.tags || []).forEach(tag => tags.add(tag))
    })
    return Array.from(tags).sort()
  })

  const hasError = computed(() => !!error.value)

  const clearError = () => {
    error.value = null
  }

  const setError = (err: BlogError) => {
    error.value = err
  }

  const fetchPosts = async () => {
    fetchLoading.value = true
    isLoading.value = true
    clearError()

    try {
      const response = await fetch('/api/blog/posts')
      if (!response.ok) {
        throw {
          code: `HTTP_${response.status}`,
          message: 'Failed to fetch blog posts',
          operation: 'fetch_posts'
        }
      }
      posts.value = await response.json()
    } catch (err: any) {
      // 當 API 無法連接時，使用預設的 mock 資料而不是拋出錯誤
      console.warn('API 無法連接，使用本地 mock 資料:', err.message)
      // posts.value 已經在初始化時設定了 mock 資料，所以不需要覆蓋
    } finally {
      fetchLoading.value = false
      isLoading.value = false
    }
  }

  const fetchPost = async (id: string) => {
    fetchLoading.value = true
    isLoading.value = true
    clearError()

    try {
      const response = await fetch(`/api/blog/posts/${id}`)
      if (!response.ok) {
        throw {
          code: `HTTP_${response.status}`,
          message: 'Failed to fetch blog post',
          operation: 'fetch_post'
        }
      }
      currentPost.value = await response.json()
    } catch (err: any) {
      const blogError: BlogError = {
        code: err.code || 'FETCH_ERROR',
        message: err.message || 'Failed to load blog post',
        operation: 'fetch_post'
      }
      setError(blogError)
      currentPost.value = null
    } finally {
      fetchLoading.value = false
      isLoading.value = false
    }
  }

  const createPost = async (postData: Omit<BlogPost, 'id' | 'publishedAt' | 'updatedAt'>) => {
    createLoading.value = true
    clearError()

    try {
      const response = await fetch('/api/blog/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(postData)
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw {
          code: `HTTP_${response.status}`,
          message: errorData.message || 'Failed to create post',
          operation: 'create_post'
        }
      }

      const newPost = await response.json()
      posts.value.push(newPost)
      return { success: true, post: newPost }
    } catch (err: any) {
      const blogError: BlogError = {
        code: err.code || 'CREATE_ERROR',
        message: err.message || 'Failed to create blog post',
        operation: 'create_post'
      }
      setError(blogError)
      return { success: false, error: blogError }
    } finally {
      createLoading.value = false
    }
  }

  const updatePost = async (id: string, postData: Partial<BlogPost>) => {
    updateLoading.value = true
    clearError()

    try {
      const response = await fetch(`/api/blog/posts/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(postData)
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw {
          code: `HTTP_${response.status}`,
          message: errorData.message || 'Failed to update post',
          operation: 'update_post'
        }
      }

      const updatedPost = await response.json()
      const index = posts.value.findIndex(post => post.id === id)
      if (index !== -1) {
        posts.value[index] = updatedPost
      }
      return { success: true, post: updatedPost }
    } catch (err: any) {
      const blogError: BlogError = {
        code: err.code || 'UPDATE_ERROR',
        message: err.message || 'Failed to update blog post',
        operation: 'update_post'
      }
      setError(blogError)
      return { success: false, error: blogError }
    } finally {
      updateLoading.value = false
    }
  }

  const deletePost = async (id: string) => {
    deleteLoading.value = true
    clearError()

    try {
      const response = await fetch(`/api/blog/posts/${id}`, {
        method: 'DELETE'
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw {
          code: `HTTP_${response.status}`,
          message: errorData.message || 'Failed to delete post',
          operation: 'delete_post'
        }
      }

      posts.value = posts.value.filter(post => post.id !== id)
      if (currentPost.value?.id === id) {
        currentPost.value = null
      }
      return { success: true }
    } catch (err: any) {
      const blogError: BlogError = {
        code: err.code || 'DELETE_ERROR',
        message: err.message || 'Failed to delete blog post',
        operation: 'delete_post'
      }
      setError(blogError)
      return { success: false, error: blogError }
    } finally {
      deleteLoading.value = false
    }
  }

  const setSearchQuery = (query: string) => {
    searchQuery.value = query
  }

  const toggleTag = (tag: string) => {
    const index = selectedTags.value.indexOf(tag)
    if (index > -1) {
      selectedTags.value.splice(index, 1)
    } else {
      selectedTags.value.push(tag)
    }
  }

  const setCategory = (category: string) => {
    selectedCategory.value = category
    currentPage.value = 1 // 重置分頁
  }

  const setPage = (page: number) => {
    if (page >= 1 && page <= totalPages.value) {
      currentPage.value = page
    }
  }

  const setPostsPerPage = (count: number) => {
    postsPerPage.value = count
    currentPage.value = 1
  }

  const clearFilters = () => {
    searchQuery.value = ''
    selectedTags.value = []
    selectedCategory.value = ''
    currentPage.value = 1
  }

  const performSearch = (query: string, filters: {
    category?: string
    tags?: string[]
    page?: number
    limit?: number
  } = {}) => {
    searchQuery.value = query
    if (filters.category !== undefined) selectedCategory.value = filters.category
    if (filters.tags !== undefined) selectedTags.value = filters.tags
    if (filters.page !== undefined) currentPage.value = filters.page
    if (filters.limit !== undefined) postsPerPage.value = filters.limit
  }

  return {
    posts,
    currentPost,
    isLoading,
    fetchLoading,
    createLoading,
    updateLoading,
    deleteLoading,
    error,
    searchQuery,
    selectedTags,
    selectedCategory,
    currentPage,
    postsPerPage,
    publishedPosts,
    filteredPosts,
    paginatedPosts,
    totalPages,
    categories,
    tagCounts,
    featuredPosts,
    allTags,
    hasError,
    fetchPosts,
    fetchPost,
    createPost,
    updatePost,
    deletePost,
    setSearchQuery,
    toggleTag,
    setCategory,
    setPage,
    setPostsPerPage,
    clearFilters,
    performSearch,
    clearError,
    setError
  }
})
